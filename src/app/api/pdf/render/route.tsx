import { NextResponse } from 'next/server';
import { Prisma } from '@prisma/client';
import prisma from '@/lib/prisma';
import {
  Document,
  Page,
  Text,
  View,
  StyleSheet,
  renderToBuffer,
} from '@react-pdf/renderer';

// 强制动态，确保在 Vercel 运行时不被静态化
export const dynamic = 'force-dynamic';
export const runtime = 'nodejs';

// 基础样式（简化版）
const styles = StyleSheet.create({
  page: {
    padding: 32,
    fontSize: 10,
    fontFamily: 'Helvetica',
    color: '#111827',
  },
  header: {
    marginBottom: 12,
  },
  title: {
    fontSize: 16,
    fontWeight: 700,
    marginBottom: 4,
  },
  subtitle: {
    fontSize: 9,
    color: '#6b7280',
  },
  seriesBox: {
    backgroundColor: '#eef2ff',
    borderLeftWidth: 4,
    borderLeftColor: '#4f46e5',
    padding: 10,
    marginBottom: 12,
  },
  seriesName: {
    fontSize: 12,
    fontWeight: 700,
    color: '#312e81',
  },
  seriesCode: {
    fontSize: 9,
    color: '#6b7280',
  },
  productBlock: {
    marginBottom: 16,
    paddingBottom: 12,
    borderBottomWidth: 1,
    borderBottomColor: '#e5e7eb',
  },
  productName: {
    fontSize: 12,
    fontWeight: 700,
    marginBottom: 4,
  },
  productSku: {
    fontSize: 9,
    color: '#6b7280',
    marginBottom: 6,
  },
  productDesc: {
    fontSize: 9,
    color: '#374151',
    marginBottom: 8,
  },
  specsTable: {
    marginTop: 6,
  },
  specsRow: {
    flexDirection: 'row',
    borderBottomWidth: 1,
    borderBottomColor: '#f3f4f6',
    paddingVertical: 4,
  },
  specsLabel: {
    width: '42%',
    color: '#6b7280',
  },
  specsValue: {
    width: '58%',
    color: '#111827',
  },
  partTitle: {
    marginTop: 8,
    marginBottom: 4,
    fontWeight: 700,
  },
  partRow: {
    flexDirection: 'row',
    paddingVertical: 3,
    borderBottomWidth: 1,
    borderBottomColor: '#f3f4f6',
    fontSize: 9,
  },
  footer: {
    position: 'absolute',
    bottom: 24,
    left: 32,
    right: 32,
    fontSize: 8,
    color: '#9ca3af',
    flexDirection: 'row',
    justifyContent: 'space-between',
  },
});

type ProductWithRelations = Prisma.ProductGetPayload<{
  include: {
    series: true;
    partNumbers: true;
    assets: {
      include: { asset: true };
    };
  };
}>;

function PdfDoc({ products, title }: { products: ProductWithRelations[]; title: string }) {
  // 按系列分组
  const grouped = products.reduce<
    Record<string, { series: ProductWithRelations['series']; items: ProductWithRelations[] }>
  >((acc, p) => {
    const code = p.series.code;
    if (!acc[code]) acc[code] = { series: p.series, items: [] };
    acc[code].items.push(p);
    return acc;
  }, {});

  const groups = Object.values(grouped);

  return (
    <Document>
      {groups.map((group, idx) => (
        <Page key={group.series.code + idx} size="A4" style={styles.page}>
          <View style={styles.header}>
            <Text style={styles.title}>{title}</Text>
            <Text style={styles.subtitle}>{new Date().toLocaleDateString('zh-CN')}</Text>
          </View>

          <View style={styles.seriesBox}>
            <Text style={styles.seriesName}>{group.series.name}</Text>
            <Text style={styles.seriesCode}>系列代码: {group.series.code}</Text>
          </View>

          {group.items.map((p) => (
            <View key={p.id} style={styles.productBlock} wrap={false}>
              <Text style={styles.productName}>{p.name}</Text>
              <Text style={styles.productSku}>SKU: {p.sku}</Text>
              {p.description && <Text style={styles.productDesc}>{p.description}</Text>}

              {/* 规格参数 */}
              {p.specifications &&
                Object.keys(p.specifications as Record<string, unknown>).length > 0 && (
                  <View style={styles.specsTable}>
                    {Object.entries(p.specifications as Record<string, unknown>).map(
                      ([k, v]) => (
                        <View key={k} style={styles.specsRow}>
                          <Text style={styles.specsLabel}>{k}</Text>
                          <Text style={styles.specsValue}>{formatValue(v)}</Text>
                        </View>
                      )
                    )}
                  </View>
                )}

              {/* 型号列表 */}
              {p.partNumbers.length > 0 && (
                <View>
                  <Text style={styles.partTitle}>型号列表</Text>
                  {p.partNumbers.map((pn) => (
                    <View key={pn.id} style={styles.partRow}>
                      <Text style={{ flex: 2 }}>{pn.partNumber}</Text>
                      <Text style={{ flex: 1 }}>{pn.category || ''}</Text>
                    </View>
                  ))}
                </View>
              )}
            </View>
          ))}

          <View style={styles.footer} fixed>
            <Text>Generated by Product Catalog System</Text>
            <Text render={({ pageNumber, totalPages }) => `${pageNumber} / ${totalPages}`} />
          </View>
        </Page>
      ))}
    </Document>
  );
}

function formatValue(v: unknown): string {
  if (v === null || v === undefined) return '';
  if (typeof v === 'object') return JSON.stringify(v);
  return String(v);
}

async function generatePdfBuffer(products: ProductWithRelations[]) {
  const safeProducts = JSON.parse(JSON.stringify(products)) as ProductWithRelations[];
  const title =
    safeProducts.length > 0 ? safeProducts[0]?.series?.name || '产品目录' : '产品目录';
  return renderToBuffer(<PdfDoc products={safeProducts} title={title} />);
}

async function getProductsByParams(
  type: 'products' | 'series',
  seriesId?: string,
  productIds?: string[],
) {
  if (type === 'series' && seriesId) {
    return prisma.product.findMany({
      where: { seriesId, isActive: true },
      include: {
        series: true,
        partNumbers: { where: { isActive: true } },
        assets: { include: { asset: true } },
      },
      orderBy: { createdAt: 'asc' },
    });
  }
  if (productIds && productIds.length > 0) {
    return prisma.product.findMany({
      where: { id: { in: productIds }, isActive: true },
      include: {
        series: true,
        partNumbers: { where: { isActive: true } },
        assets: { include: { asset: true } },
      },
    });
  }
  return [];
}

async function handleGenerate(type: 'products' | 'series', seriesId?: string, productIds?: string[]) {
  const products = await getProductsByParams(type, seriesId, productIds);
  if (!products.length) {
    return NextResponse.json(
      { success: false, error: '没有找到要生成的产品' },
      { status: 400 },
    );
  }
  const buffer = await generatePdfBuffer(products);
  return new NextResponse(buffer, {
    status: 200,
    headers: {
      'Content-Type': 'application/pdf',
      'Content-Disposition': `inline; filename="catalog.pdf"`,
      'Content-Length': buffer.length.toString(),
    },
  });
}

export async function OPTIONS() {
  return NextResponse.json({}, { status: 200 });
}

export async function GET(request: Request) {
  try {
    const { searchParams } = new URL(request.url);
    const type = (searchParams.get('type') as 'products' | 'series') || 'products';
    const seriesId = searchParams.get('seriesId') || undefined;
    const idsParam = searchParams.get('productIds') || '';
    const productIds = idsParam ? idsParam.split(',').filter(Boolean) : undefined;
    return await handleGenerate(type, seriesId, productIds);
  } catch (error) {
    console.error('服务端生成PDF失败(GET):', error);
    return NextResponse.json(
      { success: false, error: '服务端生成PDF失败' },
      { status: 500 },
    );
  }
}

export async function POST(request: Request) {
  try {
    const body = await request.json();
    const { productIds, seriesId, type = 'products' } = body as {
      productIds?: string[];
      seriesId?: string;
      type?: 'products' | 'series';
    };
    return await handleGenerate(type, seriesId, productIds);
  } catch (error) {
    console.error('服务端生成PDF失败:', error);
    return NextResponse.json(
      { success: false, error: '服务端生成PDF失败' },
      { status: 500 },
    );
  }
}

